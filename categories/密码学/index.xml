<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>密码学 on Y4ph3tS blog</title>
    <link>http://localhost:1313/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/</link>
    <description>Recent content in 密码学 on Y4ph3tS blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 05 Aug 2024 08:33:21 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>智能密码钥匙与APDU学习笔记</title>
      <link>http://localhost:1313/posts/%E6%99%BA%E8%83%BD%E5%AF%86%E7%A0%81%E9%92%A5%E5%8C%99%E4%B8%8Eapdu%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 05 Aug 2024 08:33:21 +0800</pubDate>
      <guid>http://localhost:1313/posts/%E6%99%BA%E8%83%BD%E5%AF%86%E7%A0%81%E9%92%A5%E5%8C%99%E4%B8%8Eapdu%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h4 id=&#34;智能密码钥匙&#34;&gt;智能密码钥匙&lt;/h4&gt;&#xA;&lt;p&gt;智能密码钥匙是一种终端密码设备，具备密码运算、密钥管理功能，主要用于存储用户秘密信息（如私钥、数字证书），并完成数据加解密、数据完整性校验、数字签名、访问控制等功能。&lt;/p&gt;&#xA;&lt;p&gt;智能密码钥匙应用数据接口数据格式位于智能密码钥匙应用程序和设备之间，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps1.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;智能密码钥匙应用数据接口与设备之间的数据交换以APDU的形式进行编码。APDU可包含有命令报文或响应报文，它从设备接口发送到密码钥匙，或者相反地由密码钥匙发送到设备接口。&lt;/p&gt;&#xA;&lt;h4 id=&#34;命令apdu&#34;&gt;&lt;strong&gt;命令APDU&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;如图所示，本部分所定义的命令APDU由下列内容组成：&lt;/p&gt;&#xA;&lt;p&gt;——必备的4字节命令头（CLA INS P1P2）；&lt;/p&gt;&#xA;&lt;p&gt;——有条件的可变长度主体。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps2.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在命令APDU的数据字段中出现的字节数用Lc来表示。&lt;/p&gt;&#xA;&lt;p&gt;在响应APDU的数据字段中期望的字节最大数用Le（期望数据的长度）来表示。当Le字段只包含0时，则要求有效数据字节的最大数。命令APDU有以下四种结构&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps3.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在情况1时，长度Lc为0，因此Lc字段和数据字段都为空。长度Le也为0，因此Le字段为空。从而，命令体为空。&lt;/p&gt;&#xA;&lt;p&gt;在情况2时，长度Lc为0，因此Lc字段和数据字段都为空。长度Le不为0，因此Le字段存在。从而，命令体由Le字段组成。&lt;/p&gt;&#xA;&lt;p&gt;在情况3时，长度Lc不为0，因此Lc字段存在，并且数据字段由Lc后续字节组成。长度Le为0，因此Le字段为空。从而命令体由Lc字段后紧跟着数据字段组成。&lt;/p&gt;&#xA;&lt;p&gt;在情况4时，长度Lc不为0，因此Lc字段存在，并且数据字段由Lc后续字节组成。长度Le也不为0，因此Le字段也存在。从而命令体由Lc字段后紧跟着数据字段和Le字段组成。&lt;/p&gt;&#xA;&lt;h4 id=&#34;响应apdu&#34;&gt;&lt;strong&gt;响应APDU&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;响应APDU由以下部分组成：&lt;/p&gt;&#xA;&lt;p&gt;——有条件的可变长度主体；&lt;/p&gt;&#xA;&lt;p&gt;——必备的2字节状态字（SW1—SW2）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps4.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在响应APDU的数据字段中呈现的字节数用Lr来表示。&lt;/p&gt;&#xA;&lt;p&gt;状态字对“命令响应对”之后的接收实体的状态进行了编码。&lt;/p&gt;&#xA;&lt;p&gt;注：如果该命令被放弃，则响应APDU是一个状态字，它按2个状态字节来编码出错条件。&lt;/p&gt;&#xA;&lt;h4 id=&#34;命令头数据字段和响应状态字的编码约定&#34;&gt;&lt;strong&gt;命令头、数据字段和响应状态字的编码约定&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps5.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;l CLA（类别）字节&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps6.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;l INS（指令）字节&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps7.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps8.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;状态字节&#34;&gt;&lt;strong&gt;状态字节&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;响应的状态字节SWI-SW2表示了密码钥匙内的处理状态。下图示出了标准定义的值的结构方案。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps9.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps10.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps11.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps12.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;实操中重点关注APDU报文部分，报文可用Bushound进行抓取，报文分析参考标准GM/T 0017-2012《智能密码钥匙 密码应用接口数据格式规范》&lt;/p&gt;&#xA;&lt;p&gt;以某段模拟数据为例进行分析，文件包含有设备、长度、命令、数据、描述等信息&lt;/p&gt;&#xA;&lt;h4 id=&#34;签名报文&#34;&gt;&lt;strong&gt;签名报文&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;分析时首先寻找签名部分，如下图&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps14.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;解题依据：ECC签名命令报文在标准中定义以8074开头，其他内容为P1、P2、Lc、Data、Le&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps15.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;根据响应长度即可解构出报文数据，8074为报文头，P1字段为02，P2为00，Lc字段为000024，DATA中的应用ID为1000，容器ID为3001，之后36比特为数据，最后2比特0000为Le值&lt;/p&gt;&#xA;&lt;h4 id=&#34;响应报文&#34;&gt;&lt;strong&gt;响应报文&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;签名报文完成后寻找响应报文，响应报文状态码在标准中定义如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps16.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;9000为正确执行，因此在数据包中寻找签名报文后响应为9000的数据，往前数32位即为签名数据，由于数据格式问题，需要排除签名第二行开头的5e，其实需排除每段响应报文的第一个字节（但是标准中并没有找到，和大佬交流后默认所有数据进行排除）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps17.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;提取证书&#34;&gt;&lt;strong&gt;提取证书&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;在APDU中有导出证书操作，根据GM/T 0017中的规定，在导出证书操作中的命令报文编码如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps18.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;因此在寻找报文时主要先看命令头，以上述APDU报文为例进行分析，筛选804E即可找到导出证书部分的报文，其中包含证书，且证书为加密证书。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps19.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;此时直接提取会发现证书无法解析，因为在证书以6A 9E为结尾时表明还未传输完毕，需继续寻找下一个804E字段，直至到9000正确响应，但是其中的数据需进行区分，从第一个3082证书头开始，到6A 9E为证书有效内容，另外第二个包则需要按照签名值长度往前数对应字节数进行拼接，最终有效部分如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps20.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;取出相应内容后证书即可解析&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps21.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;因一些原因，该段报文的数据包无法给出，建议有条件的朋友自行抓取&lt;/p&gt;</description>
    </item>
    <item>
      <title>SM2与KDF学习笔记</title>
      <link>http://localhost:1313/posts/sm2%E5%92%8Ckdf/</link>
      <pubDate>Wed, 12 Jun 2024 05:12:49 +0800</pubDate>
      <guid>http://localhost:1313/posts/sm2%E5%92%8Ckdf/</guid>
      <description>&lt;h2 id=&#34;sm2加密算法&#34;&gt;SM2加密算法&lt;/h2&gt;&#xA;&lt;p&gt;SM2算法是一种基于椭圆曲线密码的公钥密码算法，其安全性主要基于椭圆曲线离散对数难题。该算法由国家密码管理局设计并公开，是我国自主创新的一种密码算法，可应用于数据加密、解密、数字签名等操作。SM2算法包括密钥生成算法、加密算法、解密算法和数字签名算法等部分。&lt;/p&gt;&#xA;&lt;p&gt;SM2加密算法过程如下：&lt;/p&gt;&#xA;&lt;p&gt;用户A的原始数据为椭圆曲线系统参数、长度为klen比特的消息M、公钥PB&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;产生随机数k∈[1,n-1]&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算椭圆曲线点C1=[k]G=(x1,y1)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算椭圆曲线点S=[h]PB&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算[k]PB=(x2,y2)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算t=KDF(x2||y2,klen)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算C2=M⊕t&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算C3=Hash(x2||M||y2)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;输出密文C=C1||C2||C3&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../index_files/image-20241201151129640.png&#34; alt=&#34;image-20241201151129640&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;其中椭圆曲线方程为&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../index_files/wps22.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;密钥派生函数kdf&#34;&gt;密钥派生函数KDF&lt;/h2&gt;&#xA;&lt;p&gt;KDF密钥派生函数在标准GB/T 32918.4 《信息安全技术 SM2椭圆曲线公钥密码算法 第4部分：公钥加密算法》中定义，本质上是进行哈希运算扩展长度，再截取相应长度字段，如下所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../index_files/image-20241201151216812.png&#34; alt=&#34;image-20241201151216812&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;使用Python代码实现SM2中的KDF函数如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; math &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; ceil&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; gmssl.sm3 &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; sm3_hash&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Z&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;57E7B63623FAE5F08CDA468E872A20AFA03DED41BF1403770E040DC83AF31A67991F2B01EBF9EFD8881F0A0493000603&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hex2byte&lt;/span&gt;(msg): &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ml &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(msg)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ml &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; msg&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ml &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(len(msg)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  msg_byte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(ml):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# print(msg[i*2:i*2+2])&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    msg_byte&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(int(msg[i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;],&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; msg_byte&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;KDF&lt;/span&gt;(Z,klen): &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  klen &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(klen)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ct &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rcnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ceil(klen&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Zin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hex2byte(Z)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Ha &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(rcnt):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Zin  &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; hex2byte(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%08x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; ct)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# print(msg)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    Ha &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Ha &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sm3_hash(msg)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# print(Ha)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    ct &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Ha[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;: klen &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(KDF(Z,&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;upper())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其实KDF就是一个使用SM3算法不断拓展长度的过程，对上述脚本进行分析&lt;/p&gt;</description>
    </item>
    <item>
      <title>keytool 生成证书链</title>
      <link>http://localhost:1313/posts/keytool%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E9%93%BE/</link>
      <pubDate>Tue, 14 Feb 2023 01:21:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/keytool%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E9%93%BE/</guid>
      <description>&lt;h2 id=&#34;数字证书基本概念&#34;&gt;数字证书基本概念&lt;/h2&gt;&#xA;&lt;p&gt;数字证书‌是一种由受信任的第三方机构（称为证书颁发机构，CA）颁发的电子文档，用于证明公钥的所有权。数字证书包含了证书持有者的信息（如名称和电子邮件地址）、证书持有者的公钥、证书有效期以及CA的签名等信息。其主要作用包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;‌&lt;strong&gt;身份验证&lt;/strong&gt;‌：帮助用户验证对方的身份，确保通信双方是合法的。&lt;/li&gt;&#xA;&lt;li&gt;‌&lt;strong&gt;数据加密&lt;/strong&gt;‌：通过公钥和私钥配对，保证数据传输的安全性。&lt;/li&gt;&#xA;&lt;li&gt;‌&lt;strong&gt;数据完整性&lt;/strong&gt;‌：通过数字签名确认数据在传输过程中未被篡改‌。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;‌证书链‌是一系列数字证书的集合，用于建立一个信任路径，从而验证证书的有效性。证书链从一个受信任的根证书颁发机构（Root CA）开始，经过一个或多个中间证书颁发机构（Intermediate  CAs），最终到达目标证书（如服务器或个人证书）。每个中间CA的证书都由上一级CA签名。证书链的工作原理基于信任传递机制，即如果你信任根证书颁发机构，那么你也可以信任它所签发的所有证书，包括中间CA证书和最终的服务器或个人证书。这种机制确保了数字证书体系的安全性和可扩展性‌。&lt;/p&gt;&#xA;&lt;h3 id=&#34;数字证书和证书链的重要性&#34;&gt;数字证书和证书链的重要性&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;‌&lt;strong&gt;建立信任关系&lt;/strong&gt;‌：通过验证证书链，用户可以确认一个网站的真实性和安全性，防止钓鱼攻击和确保网站身份的真实性‌。&lt;/li&gt;&#xA;&lt;li&gt;‌&lt;strong&gt;加强数据安全&lt;/strong&gt;‌：数字证书链确保了公钥的真实来源，使得数据加密和数字签名过程更加安全可靠‌。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;生成根证书&#34;&gt;生成根证书&lt;/h2&gt;&#xA;&lt;p&gt;安装好java，确保keytool可以正常使用，开始配置证书链&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;keytool -genkeypair -validity 36500 -keyalg EC -keypass 12345678 -storepass 12345678 -dname &amp;#34;CN=y4,C=CN,OU=y4&amp;#34; -alias rootca -keystore root.jks&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;../index_files/image-20241207102750805.png&#34; alt=&#34;image-20241207102750805&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;此命令使用椭圆曲线secp256r1算法，产生一个256位的EC密钥对，并保存到njhx_root.jks中。使用以下命令查看密钥库的信息，会发现发布者与所有者都是y4&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; keytool -list -keystore root.jks -keypass 12345678 -storepass 12345678 -v&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;../index_files/image-20241207103012129.png&#34; alt=&#34;image-20241207103012129&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;从根证书密钥库导出根证书&#34;&gt;从根证书密钥库导出根证书&lt;/h2&gt;&#xA;&lt;p&gt;使用keytool的导出功能，从密钥库中导出根证书，输入密钥库的密码，导出的证书文件为rootca.cer命令如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;keytool -exportcert -validity 36500 -alias rootca -file root.cer -keystore root.jks -keypass 12345678 -storepass 12345678&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;../index_files/image-20241207103217902.png&#34; alt=&#34;image-20241207103217902&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;生成二级证书密钥库&#34;&gt;生成二级证书密钥库&lt;/h2&gt;&#xA;&lt;p&gt;二级证书需要由根证书签发。&lt;/p&gt;&#xA;&lt;p&gt;首先使用keytool生成二级证书的密钥库，但是此时还是自签的，我们需要从中生成一个二级证书请求（其中包含了二级证书的公钥）；&lt;/p&gt;&#xA;&lt;p&gt;然后将证书请求发送到rootca签发二级证书；&lt;/p&gt;&#xA;&lt;p&gt;最后，我们将rootca签发的二级证书导入到证书密钥库中，完成二级证书的生成。&lt;/p&gt;&#xA;&lt;p&gt;下面命令是生成二级证书密钥库，密钥库的名称为spky4，此时仍是自签的，证书颁发者和使用者都是自已：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;keytool -genkeypair -validity 36500 -keyalg EC -keypass 12345678 -storepass 12345678 -dname &amp;#34;CN=y4.com,C=CN,OU=y4&amp;#34; -alias spky4 -keystore sub.jks&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;../index_files/image-20241207103421561.png&#34; alt=&#34;image-20241207103421561&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
