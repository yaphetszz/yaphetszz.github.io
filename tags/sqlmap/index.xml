<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sqlmap on Y4ph3tS blog</title>
    <link>https://yaphetszz.github.io/tags/sqlmap/</link>
    <description>Recent content in Sqlmap on Y4ph3tS blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 10 Dec 2020 02:11:09 +0800</lastBuildDate>
    <atom:link href="https://yaphetszz.github.io/tags/sqlmap/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>红队基础设施建设与改造（二）——深入理解sqlmap(下)</title>
      <link>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%BA%8C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sqlmap%E4%B8%8B/</link>
      <pubDate>Thu, 10 Dec 2020 02:11:09 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%BA%8C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sqlmap%E4%B8%8B/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文所述的一切技术仅供网络安全研究学习之用，请勿用于任何的违法用途，否则由此所产生的一切后果自负！&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;在上篇中我们分析了sqlmap的部分检测逻辑，接下来介绍之前没讲完的部分，并且填上tamper这个坑。&lt;/p&gt;&#xA;&lt;p&gt;我们继续来分析盲注的逻辑，上篇分析的布尔型盲注，本篇分析时间盲注。&lt;/p&gt;&#xA;&lt;p&gt;还是拿靶场说事，先进行正常输入，可以看到相应时间，并且返回为I don’t care who you are.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps1.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;再来随便测试几个其他的输入，返回均为I don’t care who you are.即使输入特殊字符产生了错误也不会改变，在靶场中我们知道这是一个时间型盲注，但是在实战中可能往往想不到，那如何来验证是时间型盲注呢，这就需要用到sleep函数，sleep函数用于使查询延迟执行，我们可以在navicat中做样例演示，可以看到同样的一条select 123;语句执行时间不同&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps2.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以针对时间型盲注，要判断我们的输入是否执行，只需要加上sleep函数即可，在浏览器的开发人员工具的网络选项卡中，通过瀑布流的形式我们可以看到请求的时间，以下为输入lucy’and sleep (5)#的执行结果，可以看到执行时间超过了五秒&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps3.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;那是否所有的操作都会延迟呢，我们来试试输入一串明显报错的payload，在跟上了一串的单引号后可以看到请求时间明显缩短，说明payload未执行。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps4.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;根据之前布尔盲注的经验，我们同样可以进行判断，通过if语句判断为真才执行sleep语句，效果如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps5.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们所使用的payload为lucy&amp;rsquo; and if ((substr(version(),1,1))=&amp;lsquo;5&amp;rsquo;,sleep(5),null)#&lt;/p&gt;&#xA;&lt;p&gt;sqlmap中的时间盲注就比较简单了，代码如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps6.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这边看似简单是因为sqlmap使用了响应延迟判断技术，该种技术使用了前文提到的高斯分布，高斯分布可以识别一个响应是否与普通响应产生于一种机制。在sqlmap的xml文件中包含了各种攻击向量，其中常见的向量为&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps7.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们在案例中的测试也使用了其中一个向量，成功的向量如下图所示&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps8.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来我们具体分析一下数据包，以下为攻击完整过程的截图&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps9.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来就是紧张刺激的payload分析了，看看wireshark抓到的数据包，由于之前进行了大量其他测试，我们只需要分析time-based Injection即可。追踪到的第一个包是eq50分片&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps10.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;url经过转码后如下：&lt;/p&gt;&#xA;&lt;p&gt;/pikachu/vul/sqli/sqli_blind_t.php?name=123&amp;rsquo; AND (SELECT 1671 FROM (SELECT(SLEEP(5)))GSuc) AND &amp;lsquo;sRRR&amp;rsquo;=&amp;lsquo;sRRR&amp;amp;submit=查询&lt;/p&gt;&#xA;&lt;p&gt;此时控制台输出进行了两次询问，因为sqlmap疑似发现存在注入&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps11.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在这之前还有两次和上述相同的发包，应该是用于响应检测。之后就是一系列UNION select的探测，对应的是包含了orderby等参数，与控制台对应输出相同，即1-20列探测。&lt;/p&gt;&#xA;&lt;p&gt;从77组开始请求地址改变，根据之前的分析此时应该进入了误报检测&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps12.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;以下记录为77开始的payload&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 3753 FROM (SELECT(SLEEP(5-(IF(57=57,0,5)))))Ndjp) AND &amp;#39;&lt;/span&gt;HxIh&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;HxIh&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 5365 FROM (SELECT(SLEEP(5-(IF(57=65,0,5)))))irpj) AND &amp;#39;&lt;/span&gt;YVSA&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;YVSA&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 7844 FROM (SELECT(SLEEP(5-(IF(57=98,0,5)))))lPgR) AND &amp;#39;&lt;/span&gt;YJgx&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;YJgx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 9479 FROM (SELECT(SLEEP(5-(IF(98=65,0,5)))))ZaRe) AND &amp;#39;&lt;/span&gt;kXSW&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;kXSW&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 6042 FROM (SELECT(SLEEP(5-(IF(65=65,0,5)))))OReg) AND &amp;#39;&lt;/span&gt;EOyg&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;EOyg&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 9179 FROM (SELECT(SLEEP(5-(IF(98 65,0,5)))))GkMV) AND &amp;#39;&lt;/span&gt;vZOZ&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;vZOZ&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而从85组开始又出现了新的变化&lt;/p&gt;</description>
    </item>
    <item>
      <title>红队基础设施建设与改造（二）——深入理解sqlmap(上)</title>
      <link>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%BA%8C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sqlmap%E4%B8%8A/</link>
      <pubDate>Wed, 02 Dec 2020 08:54:33 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%BA%8C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sqlmap%E4%B8%8A/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文所述的一切技术仅供网络安全研究学习之用，请勿用于任何的违法用途，否则由此所产生的一切后果自负！&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;上一篇文章我们写了Nmap的分析与改造，本篇将继续分析炙手可热的工具sqlmap。这篇文章介绍的修改的东西不多，针对sqlmap的分析较多。剖析了sqlmap的大部分功能点和所有的检测逻辑，同时还会讲到tamper的分析以及tamper的编写。由于篇幅较长，为了避免大家看着难受，准备分为上下两篇来写。&lt;/p&gt;&#xA;&lt;p&gt;首先我们通过靶场环境构造漏洞场景，靶场为pikachu，github地址为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zhuifengshaonianhanlu/pikachu&#34;&gt;https://github.com/zhuifengshaonianhanlu/pikachu&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;进入存在注入漏洞的页面&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps1.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;进行抓包&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps2.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;丢进sqlmap可以看到能跑出结果&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps3.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;进行一次完整的过程时监听流量并筛选&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps4.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在流量中我们可以很明显地发现会产生一长串的请求，筛选一下POST请求就能看到发送的payload&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps5.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这是简单的sqlmap发包内容，我们继续深入。&lt;/p&gt;&#xA;&lt;p&gt;很多人可能只了解了sqlmap的用法，甚至都不了解用法，参数只会-u -r &amp;ndash;level –risk几个，偶尔看了大佬的文章知道了&amp;ndash;tamper但是并不了解原理。接下来就给大家从多个方面来解析一下sqlmap这款神器。&lt;/p&gt;&#xA;&lt;p&gt;首先来看看针对靶场进行测试时的输出&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps6.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;第一行进行了包格式判断，如果无法识别将直接弹出错误并推出；接下来进行了连接测试，测试到目标的连接情况；然后进行WAF和IPS检测；再判断目标是否稳定；之后进行参数的动态性检测，启发式参数（xss等）测试；之后就开始了对包中可能存在的注入点的检测。&lt;/p&gt;&#xA;&lt;p&gt;我们对sqlmap的代码进行跟踪，首先第一环节为连接测试部分，对应代码在checks.py文件中&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps7.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;判断目标连接存活后开始进入下一环节，IPS和WAF的探测，核心代码也位于checks.py中，可以看到其中参考了http://seclists.org/nmap-dev/2011/q2/att-1005/http-waf-detect.nse&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps8.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上面的参考链接是一个Nmap的脚本，也是我们上一篇文章中所说的，不过上一篇文章没有对NSE脚本的开发做深入介绍（下次一定补上。下次一定！）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps9.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;先来看一下脚本，我们发现主要是通过如下定义的两个攻击向量来进行检测的&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps10.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上述的攻击向量包含了大多数常见的攻击类型，可以看到有目录穿越，敏感文件读取，SQL注入，PHP代码执行，XSS等方式，通常这几种payload会触发几乎所有防护软件的策略。可以看到在sqlmap中，payload也做了定义，定义在/lib/core/settings.py文件中，跟踪变量后可以看到其中的payload，与NSE脚本中的攻击向量相差无几。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps11.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;判断完WAF后就是对稳定性的检测，代码还是在checks.py中&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps12.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;该方式主要通过请求时间判断，在开头的注释中写道两次请求页面，判断不同请求的时间，而这个时间变量在跟踪后得到DELAY值超过0.5时即返回不稳定&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps13.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;启发式注入检测处于heuristicCheckSqlInjection方法中，启发式注入过程中，payload生成是由,&amp;rsquo;&amp;quot;().六种字符随机组成的长度为10的字符串，同时满足&amp;rsquo;和&amp;quot;都只有一个。启发式注入的目的就是让Web应用报错，如果Web应用开启了错误回显，就可以快速识别DBMS（正则匹配）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps14.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来针对具体场景进行分析，我们在该案例之前的靶场中，具有如下显示，可以看到正常发包时正常回显，&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps15.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;输入and 1=1以及and 1=2的测试判断是否存在注入&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps16.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps17.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;继续输入payload，进行列数判断&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps18.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps19.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;通过union select 1,2判断输出位置&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps20.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;进一步获取数据（省略了爆表列名和字段名的操作）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps21.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;该种方式为union注入，是sqlmap中判断较为复杂的一种，因为脚本需要完成order by探测列数，select 判断列数，union select 1,2,&amp;hellip;判断输出位置，我们从代码来看sqlmap的UNION select检测逻辑，在checks.py中&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps22.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;跟进函数后发现检测文件位于/lib/techniques/union中&lt;/p&gt;&#xA;&lt;p&gt;列数判断，即order by判断&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps23.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;之后进行select null判断列数，&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps24.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在进行该判断时经查sqlmap使用了网页相似度对比技术和高斯分布&lt;/p&gt;&#xA;&lt;p&gt;select null列数探测技术在进行时，会首先指定列数猜测过程中的最大值与最小值（指定列数 最少/最小值 为1，最多/最大值 为10），sqlmap会同时发送10个数据包，包含1个NULL至10个NULL，取回10个包的响应后进行网页相似度分析，并获取网页相似度数值（共10个，非True/False）。在这10个数值中，如果select null列数探测成功，那么成功那个响应的网页相似度数值只可能是最大值或者最小值。对10个数值中去除最大值和最小值后，留下8个值，可以认为，这8个值都是列数猜测不成功返回的响应，对这个8个数据进行高斯分布建模，得出的模型就是列数猜测不成功的模型。现在使用最大值或者最小值来计算是否符合这个不成功的模型，如果符合，说明这个数据也是列数猜测不成功的响应，如果不符合，说明这个数据也是列数猜测成功的响应。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
