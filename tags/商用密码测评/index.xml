<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>商用密码测评 on Y4ph3tS blog</title>
    <link>https://yaphetszz.github.io/tags/%E5%95%86%E7%94%A8%E5%AF%86%E7%A0%81%E6%B5%8B%E8%AF%84/</link>
    <description>Recent content in 商用密码测评 on Y4ph3tS blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 05 Aug 2024 08:33:21 +0800</lastBuildDate>
    <atom:link href="https://yaphetszz.github.io/tags/%E5%95%86%E7%94%A8%E5%AF%86%E7%A0%81%E6%B5%8B%E8%AF%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>智能密码钥匙与APDU学习笔记</title>
      <link>https://yaphetszz.github.io/posts/%E6%99%BA%E8%83%BD%E5%AF%86%E7%A0%81%E9%92%A5%E5%8C%99%E4%B8%8Eapdu%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 05 Aug 2024 08:33:21 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/%E6%99%BA%E8%83%BD%E5%AF%86%E7%A0%81%E9%92%A5%E5%8C%99%E4%B8%8Eapdu%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h4 id=&#34;智能密码钥匙&#34;&gt;智能密码钥匙&lt;/h4&gt;&#xA;&lt;p&gt;智能密码钥匙是一种终端密码设备，具备密码运算、密钥管理功能，主要用于存储用户秘密信息（如私钥、数字证书），并完成数据加解密、数据完整性校验、数字签名、访问控制等功能。&lt;/p&gt;&#xA;&lt;p&gt;智能密码钥匙应用数据接口数据格式位于智能密码钥匙应用程序和设备之间，如下图所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps1.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;智能密码钥匙应用数据接口与设备之间的数据交换以APDU的形式进行编码。APDU可包含有命令报文或响应报文，它从设备接口发送到密码钥匙，或者相反地由密码钥匙发送到设备接口。&lt;/p&gt;&#xA;&lt;h4 id=&#34;命令apdu&#34;&gt;&lt;strong&gt;命令APDU&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;如图所示，本部分所定义的命令APDU由下列内容组成：&lt;/p&gt;&#xA;&lt;p&gt;——必备的4字节命令头（CLA INS P1P2）；&lt;/p&gt;&#xA;&lt;p&gt;——有条件的可变长度主体。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps2.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在命令APDU的数据字段中出现的字节数用Lc来表示。&lt;/p&gt;&#xA;&lt;p&gt;在响应APDU的数据字段中期望的字节最大数用Le（期望数据的长度）来表示。当Le字段只包含0时，则要求有效数据字节的最大数。命令APDU有以下四种结构&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps3.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在情况1时，长度Lc为0，因此Lc字段和数据字段都为空。长度Le也为0，因此Le字段为空。从而，命令体为空。&lt;/p&gt;&#xA;&lt;p&gt;在情况2时，长度Lc为0，因此Lc字段和数据字段都为空。长度Le不为0，因此Le字段存在。从而，命令体由Le字段组成。&lt;/p&gt;&#xA;&lt;p&gt;在情况3时，长度Lc不为0，因此Lc字段存在，并且数据字段由Lc后续字节组成。长度Le为0，因此Le字段为空。从而命令体由Lc字段后紧跟着数据字段组成。&lt;/p&gt;&#xA;&lt;p&gt;在情况4时，长度Lc不为0，因此Lc字段存在，并且数据字段由Lc后续字节组成。长度Le也不为0，因此Le字段也存在。从而命令体由Lc字段后紧跟着数据字段和Le字段组成。&lt;/p&gt;&#xA;&lt;h4 id=&#34;响应apdu&#34;&gt;&lt;strong&gt;响应APDU&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;响应APDU由以下部分组成：&lt;/p&gt;&#xA;&lt;p&gt;——有条件的可变长度主体；&lt;/p&gt;&#xA;&lt;p&gt;——必备的2字节状态字（SW1—SW2）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps4.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在响应APDU的数据字段中呈现的字节数用Lr来表示。&lt;/p&gt;&#xA;&lt;p&gt;状态字对“命令响应对”之后的接收实体的状态进行了编码。&lt;/p&gt;&#xA;&lt;p&gt;注：如果该命令被放弃，则响应APDU是一个状态字，它按2个状态字节来编码出错条件。&lt;/p&gt;&#xA;&lt;h4 id=&#34;命令头数据字段和响应状态字的编码约定&#34;&gt;&lt;strong&gt;命令头、数据字段和响应状态字的编码约定&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps5.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;l CLA（类别）字节&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps6.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;l INS（指令）字节&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps7.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps8.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;状态字节&#34;&gt;&lt;strong&gt;状态字节&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;响应的状态字节SWI-SW2表示了密码钥匙内的处理状态。下图示出了标准定义的值的结构方案。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps9.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps10.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps11.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps12.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;实操中重点关注APDU报文部分，报文可用Bushound进行抓取，报文分析参考标准GM/T 0017-2012《智能密码钥匙 密码应用接口数据格式规范》&lt;/p&gt;&#xA;&lt;p&gt;以某段模拟数据为例进行分析，文件包含有设备、长度、命令、数据、描述等信息&lt;/p&gt;&#xA;&lt;h4 id=&#34;签名报文&#34;&gt;&lt;strong&gt;签名报文&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;分析时首先寻找签名部分，如下图&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps14.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;解题依据：ECC签名命令报文在标准中定义以8074开头，其他内容为P1、P2、Lc、Data、Le&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps15.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;根据响应长度即可解构出报文数据，8074为报文头，P1字段为02，P2为00，Lc字段为000024，DATA中的应用ID为1000，容器ID为3001，之后36比特为数据，最后2比特0000为Le值&lt;/p&gt;&#xA;&lt;h4 id=&#34;响应报文&#34;&gt;&lt;strong&gt;响应报文&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;签名报文完成后寻找响应报文，响应报文状态码在标准中定义如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps16.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;9000为正确执行，因此在数据包中寻找签名报文后响应为9000的数据，往前数32位即为签名数据，由于数据格式问题，需要排除签名第二行开头的5e，其实需排除每段响应报文的第一个字节（但是标准中并没有找到，和大佬交流后默认所有数据进行排除）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps17.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;提取证书&#34;&gt;&lt;strong&gt;提取证书&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;p&gt;在APDU中有导出证书操作，根据GM/T 0017中的规定，在导出证书操作中的命令报文编码如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps18.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;因此在寻找报文时主要先看命令头，以上述APDU报文为例进行分析，筛选804E即可找到导出证书部分的报文，其中包含证书，且证书为加密证书。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps19.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;此时直接提取会发现证书无法解析，因为在证书以6A 9E为结尾时表明还未传输完毕，需继续寻找下一个804E字段，直至到9000正确响应，但是其中的数据需进行区分，从第一个3082证书头开始，到6A 9E为证书有效内容，另外第二个包则需要按照签名值长度往前数对应字节数进行拼接，最终有效部分如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps20.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;取出相应内容后证书即可解析&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../ksohtml1312/wps21.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;因一些原因，该段报文的数据包无法给出，建议有条件的朋友自行抓取&lt;/p&gt;</description>
    </item>
    <item>
      <title>SM2与KDF学习笔记</title>
      <link>https://yaphetszz.github.io/posts/sm2%E5%92%8Ckdf/</link>
      <pubDate>Wed, 12 Jun 2024 05:12:49 +0800</pubDate>
      <guid>https://yaphetszz.github.io/posts/sm2%E5%92%8Ckdf/</guid>
      <description>&lt;h2 id=&#34;sm2加密算法&#34;&gt;SM2加密算法&lt;/h2&gt;&#xA;&lt;p&gt;SM2算法是一种基于椭圆曲线密码的公钥密码算法，其安全性主要基于椭圆曲线离散对数难题。该算法由国家密码管理局设计并公开，是我国自主创新的一种密码算法，可应用于数据加密、解密、数字签名等操作。SM2算法包括密钥生成算法、加密算法、解密算法和数字签名算法等部分。&lt;/p&gt;&#xA;&lt;p&gt;SM2加密算法过程如下：&lt;/p&gt;&#xA;&lt;p&gt;用户A的原始数据为椭圆曲线系统参数、长度为klen比特的消息M、公钥PB&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;产生随机数k∈[1,n-1]&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算椭圆曲线点C1=[k]G=(x1,y1)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算椭圆曲线点S=[h]PB&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算[k]PB=(x2,y2)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算t=KDF(x2||y2,klen)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算C2=M⊕t&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;计算C3=Hash(x2||M||y2)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;输出密文C=C1||C2||C3&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../index_files/image-20241201151129640.png&#34; alt=&#34;image-20241201151129640&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;其中椭圆曲线方程为&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../index_files/wps22.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;密钥派生函数kdf&#34;&gt;密钥派生函数KDF&lt;/h2&gt;&#xA;&lt;p&gt;KDF密钥派生函数在标准GB/T 32918.4 《信息安全技术 SM2椭圆曲线公钥密码算法 第4部分：公钥加密算法》中定义，本质上是进行哈希运算扩展长度，再截取相应长度字段，如下所示：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../index_files/image-20241201151216812.png&#34; alt=&#34;image-20241201151216812&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;使用Python代码实现SM2中的KDF函数如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; math &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; ceil&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; gmssl.sm3 &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; sm3_hash&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Z&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;57E7B63623FAE5F08CDA468E872A20AFA03DED41BF1403770E040DC83AF31A67991F2B01EBF9EFD8881F0A0493000603&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hex2byte&lt;/span&gt;(msg): &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ml &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(msg)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ml &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; msg&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ml &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(len(msg)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  msg_byte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(ml):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# print(msg[i*2:i*2+2])&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    msg_byte&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(int(msg[i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;],&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; msg_byte&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;KDF&lt;/span&gt;(Z,klen): &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  klen &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(klen)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ct &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rcnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ceil(klen&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Zin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hex2byte(Z)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Ha &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(rcnt):&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Zin  &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; hex2byte(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%08x&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; ct)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# print(msg)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    Ha &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Ha &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sm3_hash(msg)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# print(Ha)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;​&lt;/span&gt;    ct &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Ha[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;: klen &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(KDF(Z,&lt;span style=&#34;color:#ae81ff&#34;&gt;19&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;upper())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其实KDF就是一个使用SM3算法不断拓展长度的过程，对上述脚本进行分析&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
